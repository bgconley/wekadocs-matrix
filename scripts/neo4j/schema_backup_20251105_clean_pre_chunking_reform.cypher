// ============================================================================
// WekaDocs GraphRAG Schema v2.1 - CLEAN STATE BACKUP
// ============================================================================
// BACKUP METADATA:
//   Created:     2025-11-05
//   Source:      localhost:7687 (post-cleanup, pre-chunking-reform)
//   Schema Ver:  v2.1
//   Edition:     Neo4j Community Edition
//   Purpose:     Clean slate backup before implementing RAG chunking improvements
//
// BACKUP CAPTURE METHOD:
//   This file was generated by introspecting the running Neo4j database using:
//   - SHOW CONSTRAINTS (16 unique constraints captured)
//   - SHOW INDEXES (44+ property/vector/fulltext indexes captured)
//   - Schema metadata from SchemaVersion node (preserved through cleanup)
//
// RESTORATION INSTRUCTIONS:
//   1. Neo4j: cat schema_backup_20251105_clean_pre_chunking_reform.cypher | cypher-shell -u neo4j -p <password>
//   2. Qdrant: See QDRANT_CONFIGURATION section below for Python restoration script
//   3. Verify: SHOW CONSTRAINTS; SHOW INDEXES; MATCH (sv:SchemaVersion) RETURN sv;
//
// IDEMPOTENCY:
//   This script is idempotent (IF NOT EXISTS on all CREATE statements).
//   Safe to re-run multiple times without errors or duplicates.
//
// COMPANION STORES:
//   Neo4j: This file (graph structure + constraints + indexes)
//   Qdrant: See QDRANT_CONFIGURATION section below for vector store setup
//
// DATA STATE AT BACKUP:
//   Neo4j:  1 node (SchemaVersion only - post data cleanup)
//   Qdrant: 0 points in chunks collection (cleaned state)
//
// CRITICAL SPECIFICATIONS:
//   Vector dimensions: 1024-D (Jina v3)
//   Embedding provider: jina-ai
//   Model: jina-embeddings-v3
//   Similarity: cosine
//   Community Edition: No property existence constraints (enforced in app layer)
//
// PRE-REFORM CHUNKING STATE:
//   This backup captures the schema before implementing the chunking reform
//   recommendations from expert RAG analysis. Current problematic settings:
//   - combine_min_tokens: 800 (will be reduced to 350)
//   - combine_target_tokens: 1500 (will be reduced to 500)
//   - combine_max_tokens: 7900 (will be reduced to 750)
//
// ============================================================================

// ============================================================================
// PART 1: CORE NODE CONSTRAINTS (Document + Section + Entities)
// ============================================================================
// Purpose: Unique identifiers for all node types
// Impact: Prevents duplicate nodes, enables fast lookups
// Captured: 16 unique constraints from deployed schema

// Document constraints (2)
CREATE CONSTRAINT document_id_unique IF NOT EXISTS
FOR (d:Document) REQUIRE d.id IS UNIQUE;

CREATE CONSTRAINT document_source_uri_unique IF NOT EXISTS
FOR (d:Document) REQUIRE d.source_uri IS UNIQUE;

// Section/Chunk constraint (1)
// NOTE: Sections are dual-labeled as :Chunk for v3 compatibility
CREATE CONSTRAINT section_id_unique IF NOT EXISTS
FOR (s:Section) REQUIRE s.id IS UNIQUE;

// Domain entity constraints (9)
CREATE CONSTRAINT command_id_unique IF NOT EXISTS
FOR (c:Command) REQUIRE c.id IS UNIQUE;

CREATE CONSTRAINT configuration_id_unique IF NOT EXISTS
FOR (c:Configuration) REQUIRE c.id IS UNIQUE;

CREATE CONSTRAINT procedure_id_unique IF NOT EXISTS
FOR (p:Procedure) REQUIRE p.id IS UNIQUE;

CREATE CONSTRAINT error_id_unique IF NOT EXISTS
FOR (e:Error) REQUIRE e.id IS UNIQUE;

CREATE CONSTRAINT concept_id_unique IF NOT EXISTS
FOR (c:Concept) REQUIRE c.id IS UNIQUE;

CREATE CONSTRAINT example_id_unique IF NOT EXISTS
FOR (e:Example) REQUIRE e.id IS UNIQUE;

CREATE CONSTRAINT step_id_unique IF NOT EXISTS
FOR (s:Step) REQUIRE s.id IS UNIQUE;

CREATE CONSTRAINT parameter_id_unique IF NOT EXISTS
FOR (p:Parameter) REQUIRE p.id IS UNIQUE;

CREATE CONSTRAINT component_id_unique IF NOT EXISTS
FOR (c:Component) REQUIRE c.id IS UNIQUE;

// Session/Query/Answer constraints (3)
CREATE CONSTRAINT session_id_unique IF NOT EXISTS
FOR (s:Session) REQUIRE s.session_id IS UNIQUE;

CREATE CONSTRAINT query_id_unique IF NOT EXISTS
FOR (q:Query) REQUIRE q.query_id IS UNIQUE;

CREATE CONSTRAINT answer_id_unique IF NOT EXISTS
FOR (a:Answer) REQUIRE a.answer_id IS UNIQUE;

// SchemaVersion constraint (1)
CREATE CONSTRAINT schema_version_singleton IF NOT EXISTS
FOR (sv:SchemaVersion) REQUIRE sv.id IS UNIQUE;

// ============================================================================
// PART 2: PROPERTY INDEXES (Document, Section, Entities)
// ============================================================================
// Purpose: Fast filtering and sorting in queries
// Impact: Query performance optimization
// Captured: 41 property indexes from deployed schema

// Document indexes (3)
CREATE INDEX document_source_type IF NOT EXISTS
FOR (d:Document) ON (d.source_type);

CREATE INDEX document_version IF NOT EXISTS
FOR (d:Document) ON (d.version);

CREATE INDEX document_last_edited IF NOT EXISTS
FOR (d:Document) ON (d.last_edited);

// Section indexes (4)
CREATE INDEX section_document_id IF NOT EXISTS
FOR (s:Section) ON (s.document_id);

CREATE INDEX section_level IF NOT EXISTS
FOR (s:Section) ON (s.level);

CREATE INDEX section_order IF NOT EXISTS
FOR (s:Section) ON (s.order);

CREATE INDEX section_parent_section_id IF NOT EXISTS
FOR (s:Section) ON (s.parent_section_id);

// Chunk indexes (4) - for dual-labeled nodes
CREATE INDEX chunk_document_id IF NOT EXISTS
FOR (c:Chunk) ON (c.document_id);

CREATE INDEX chunk_level IF NOT EXISTS
FOR (c:Chunk) ON (c.level);

CREATE INDEX chunk_order IF NOT EXISTS
FOR (c:Chunk) ON (c.order);

CREATE INDEX chunk_embedding_version IF NOT EXISTS
FOR (c:Chunk) ON (c.embedding_version);

// CitationUnit indexes (3) - Phase 7E additions
CREATE INDEX citation_unit_parent_chunk_id IF NOT EXISTS
FOR (cu:CitationUnit) ON (cu.parent_chunk_id);

CREATE INDEX citation_unit_document_id IF NOT EXISTS
FOR (cu:CitationUnit) ON (cu.document_id);

CREATE INDEX citation_unit_order IF NOT EXISTS
FOR (cu:CitationUnit) ON (cu.order);

// Domain entity indexes (6)
CREATE INDEX command_name IF NOT EXISTS
FOR (c:Command) ON (c.name);

CREATE INDEX configuration_name IF NOT EXISTS
FOR (c:Configuration) ON (c.name);

CREATE INDEX procedure_title IF NOT EXISTS
FOR (p:Procedure) ON (p.title);

CREATE INDEX error_code IF NOT EXISTS
FOR (e:Error) ON (e.code);

CREATE INDEX concept_term IF NOT EXISTS
FOR (c:Concept) ON (c.term);

CREATE INDEX component_name IF NOT EXISTS
FOR (c:Component) ON (c.name);

// Session indexes (4)
CREATE INDEX session_started_at IF NOT EXISTS
FOR (s:Session) ON (s.started_at);

CREATE INDEX session_expires_at IF NOT EXISTS
FOR (s:Session) ON (s.expires_at);

CREATE INDEX session_active IF NOT EXISTS
FOR (s:Session) ON (s.active);

CREATE INDEX session_user_id IF NOT EXISTS
FOR (s:Session) ON (s.user_id);

// Query indexes (2)
CREATE INDEX query_turn IF NOT EXISTS
FOR (q:Query) ON (q.turn);

CREATE INDEX query_asked_at IF NOT EXISTS
FOR (q:Query) ON (q.asked_at);

// Answer indexes (2)
CREATE INDEX answer_created_at IF NOT EXISTS
FOR (a:Answer) ON (a.created_at);

CREATE INDEX answer_user_feedback IF NOT EXISTS
FOR (a:Answer) ON (a.user_feedback);

// ============================================================================
// PART 3: FULL-TEXT SEARCH INDEX - Phase 7E BM25 Support
// ============================================================================
// Purpose: Enable BM25/keyword search for hybrid retrieval
// Type: FULLTEXT (Lucene-based)
// Targets: Both Chunk and CitationUnit nodes
// Captured: 1 fulltext index from deployed schema

CREATE FULLTEXT INDEX chunk_text_index_v3 IF NOT EXISTS
FOR (n:Chunk|CitationUnit) ON EACH [n.text, n.heading];

// ============================================================================
// PART 4: VECTOR INDEXES - 1024-D (CRITICAL for Phase 7E)
// ============================================================================
// Purpose: Semantic search via vector similarity
// CRITICAL SPECIFICATION: 1024 dimensions (Jina v3)
// Provider: jina-ai
// Model: jina-embeddings-v3
// Similarity: cosine
//
// DUAL INDEXES:
// We create two vector indexes on the same data (dual-labeled nodes):
// 1. section_embeddings_v2 - Primary retrieval path (Section label)
// 2. chunk_embeddings_v2 - v3 compatibility path (Chunk label)
//
// Both indexes point to the same vector_embedding property on the same nodes.
// Captured: 2 vector indexes from deployed schema

// Section vector index (primary retrieval path)
CREATE VECTOR INDEX section_embeddings_v2 IF NOT EXISTS
FOR (s:Section)
ON s.vector_embedding
OPTIONS {
  indexConfig: {
    `vector.dimensions`: 1024,
    `vector.similarity_function`: 'cosine'
  }
};

// Chunk vector index (v3 compatibility - same data, dual-labeled)
CREATE VECTOR INDEX chunk_embeddings_v2 IF NOT EXISTS
FOR (c:Chunk)
ON c.vector_embedding
OPTIONS {
  indexConfig: {
    `vector.dimensions`: 1024,
    `vector.similarity_function`: 'cosine'
  }
};

// ============================================================================
// PART 5: DUAL-LABELING FOR EXISTING SECTIONS (Migration-safe)
// ============================================================================
// Purpose: Add :Chunk label to existing :Section nodes for v3 compatibility
// Impact: Enables v3 tools to access sections via :Chunk label
// Pattern: Dual-labeling (not renaming) - both labels coexist
// Idempotent: WHERE NOT s:Chunk prevents redundant labeling
//
// For FRESH INSTALLATIONS, this is a no-op (no Sections exist yet).
// For MIGRATIONS, this adds :Chunk label to existing :Section nodes.

MATCH (s:Section)
WHERE NOT s:Chunk
SET s:Chunk;

// ============================================================================
// PART 6: SCHEMA VERSION MARKER (v2.1 - Preserved Through Cleanup)
// ============================================================================
// Purpose: Track schema version for migrations and validation
// Pattern: Singleton node with version metadata
// Idempotent: MERGE ensures only one version node exists
// Note: This node was preserved during cleanup and contains production metadata

MERGE (sv:SchemaVersion {id: 'singleton'})
SET sv.version = 'v2.1',
    sv.edition = 'community',
    sv.vector_dimensions = 1024,
    sv.embedding_provider = 'jina-ai',
    sv.embedding_model = 'jina-embeddings-v3',
    sv.updated_at = datetime(),
    sv.description = 'Phase 7E: Clean slate before chunking reform - ready for 250-400 token chunks',
    sv.validation_note = 'Property existence constraints enforced in application layer (Community Edition)',
    sv.backup_source = 'Post-cleanup pre-chunking-reform snapshot 2025-11-05',
    sv.backup_method = 'Introspected via SHOW CONSTRAINTS and SHOW INDEXES',
    sv.reform_note = 'Schema captured before implementing RAG best practice chunking (250-400 tokens)';

// ============================================================================
// PART 7: CANONICAL PROPERTY NAMES (Documentation)
// ============================================================================
// COMMUNITY EDITION NOTE:
// Property existence constraints (REQUIRE property IS NOT NULL) are not
// supported in Neo4j Community Edition. They require Enterprise Edition.
//
// VALIDATION STRATEGY:
// All required field validation is enforced in the application layer.
// See: src/shared/embedding_fields.py for validation logic.
//
// --------------------------------------------------------------------------
// CANONICAL PROPERTIES (Authoritative - used across Neo4j and Qdrant)
// --------------------------------------------------------------------------
// Section/Chunk nodes (dual-labeled :Section :Chunk):
//   - id                   (String, UNIQUE key)
//   - document_id          (String, FK to :Document.id)
//   - level                (Integer, heading depth)
//   - order                (Integer, position within parent)
//   - parent_section_id    (String, optional, logical parent anchor)
//   - heading              (String, optional)
//   - text                 (String, chunk text)
//   - is_combined          (Boolean)
//   - is_split             (Boolean)
//   - original_section_ids (List<String>)
//   - boundaries_json      (String, JSON-serialized bounds)
//   - token_count          (Integer)
//   - updated_at           (DateTime)
//   - vector_embedding     (List<Float>)  // 1024-D for jina-embeddings-v3
//   - embedding_version    (String)       // e.g., 'jina-embeddings-v3'
//   - embedding_provider   (String)       // e.g., 'jina-ai'
//   - embedding_dimensions (Integer)      // e.g., 1024
//   - embedding_timestamp  (DateTime)
//   - doc_tag              (String)       // Phase 7E: Document scope tag
//   - document_total_tokens (Integer)    // Phase 7E: Total doc tokens
//   - is_microdoc          (Boolean)     // Phase 7E: Microdoc flag
//   - source_path          (String)       // Phase 7E: Source file path
//   - tenant               (String)       // Phase 7E: Multi-tenancy
//
// CitationUnit nodes (Phase 7E):
//   - id                   (String, UNIQUE key via parent)
//   - document_id          (String, FK to :Document.id)
//   - parent_chunk_id      (String, FK to :Chunk.id)
//   - heading              (String, citation heading)
//   - text                 (String, citation text)
//   - level                (Integer, heading depth)
//   - order                (Integer, position within chunk)
//   - token_count          (Integer)
//
// Document nodes:
//   - id                   (String, UNIQUE key)
//   - source_type          (String)
//   - source_uri           (String, UNIQUE)
//   - version              (String)
//   - last_edited          (DateTime)
//   - title                (String, optional)
//   - source_url           (String, optional)
//   - path                 (String, optional)
//   - token_count          (Integer, optional)
//   - doc_tag              (String, Phase 7E: document scope tag)
//
// Query nodes:
//   - query_id             (String, UNIQUE key)
//   - text                 (String)
//   - turn                 (Integer)
//   - asked_at             (DateTime)
//
// Answer nodes:
//   - answer_id            (String, UNIQUE key)
//   - text                 (String)
//   - created_at           (DateTime)
//   - user_feedback        (String, optional)
//
// Session nodes:
//   - session_id           (String, UNIQUE key)
//   - started_at           (DateTime)
//   - expires_at           (DateTime)
//   - active               (Boolean)
//   - user_id              (String, optional)
//
// ============================================================================
// PART 8: QDRANT CONFIGURATION (Companion Vector Store)
// ============================================================================
// The Qdrant collection must be created separately using the Python client.
// This section documents the exact configuration captured from deployment.
//
// COLLECTION NAME: chunks (Phase 7E naming)
//
// RESTORATION SCRIPT (Python):
// --------------------------------------------------------------------------
// from qdrant_client import QdrantClient
// from qdrant_client.models import Distance, VectorParams
//
// client = QdrantClient(host="localhost", port=6333)
//
// # Delete collection if exists (for clean restoration)
// try:
//     client.delete_collection(collection_name="chunks")
// except:
//     pass
//
// # Create collection with exact deployed configuration
// client.create_collection(
//     collection_name="chunks",
//     vectors_config=VectorParams(
//         size=1024,
//         distance=Distance.COSINE
//     ),
//     hnsw_config={
//         "m": 16,
//         "ef_construct": 200,  # Phase 7E: Increased from 100
//         "full_scan_threshold": 10000,
//         "max_indexing_threads": 0,
//         "on_disk": False
//     },
//     optimizer_config={
//         "deleted_threshold": 0.2,
//         "vacuum_min_vector_number": 1000,
//         "default_segment_number": 2,  # Phase 7E: Increased from 0
//         "indexing_threshold": 20000,
//         "flush_interval_sec": 5,
//         "max_optimization_threads": 1
//     },
//     wal_config={
//         "wal_capacity_mb": 32,
//         "wal_segments_ahead": 0
//     },
//     shard_number=1,
//     replication_factor=1,
//     write_consistency_factor=1,
//     on_disk_payload=True
// )
//
// # Create payload indexes for fast filtering
// client.create_payload_index(
//     collection_name="chunks",
//     field_name="document_id",
//     field_schema="keyword"
// )
//
// client.create_payload_index(
//     collection_name="chunks",
//     field_name="parent_section_id",
//     field_schema="keyword"
// )
//
// client.create_payload_index(
//     collection_name="chunks",
//     field_name="order",
//     field_schema="integer"
// )
//
// client.create_payload_index(
//     collection_name="chunks",
//     field_name="updated_at",
//     field_schema="integer"
// )
//
// # Phase 7E: Additional indexes for enhanced retrieval
// client.create_payload_index(
//     collection_name="chunks",
//     field_name="doc_tag",
//     field_schema="keyword"
// )
//
// client.create_payload_index(
//     collection_name="chunks",
//     field_name="is_microdoc",
//     field_schema="bool"
// )
//
// client.create_payload_index(
//     collection_name="chunks",
//     field_name="token_count",
//     field_schema="integer"
// )
//
// print("Qdrant collection 'chunks' created successfully")
// --------------------------------------------------------------------------
//
// DEPLOYED CONFIGURATION SUMMARY:
//   Collection:       chunks
//   Vector Size:      1024 dimensions
//   Distance Metric:  Cosine
//   HNSW m:           16
//   HNSW ef_construct: 200
//   Shards:           1
//   Replication:      1
//   On-disk payload:  true
//   Status:           green (healthy)
//
// PAYLOAD SCHEMA (Canonical fields stored in Qdrant):
//   - id (string) - Matches Neo4j Chunk.id
//   - document_id (string, indexed) - FK to Document
//   - parent_section_id (string, indexed) - Logical parent
//   - level (integer) - Heading depth
//   - order (integer, indexed) - Position within parent
//   - heading (string) - Section heading
//   - text (string) - Full chunk text
//   - token_count (integer, indexed) - Token count
//   - is_combined (boolean) - Chunk combination flag
//   - is_split (boolean) - Chunk split flag
//   - original_section_ids (list<string>) - Source sections
//   - boundaries_json (string) - JSON-serialized bounds
//   - updated_at (integer/string, indexed) - Timestamp
//   - embedding_version (string) - Model version
//   - embedding_provider (string) - Provider name
//   - embedding_dimensions (integer) - Dimension count
//   - embedding_timestamp (string) - Embedding creation time
//   - doc_tag (string, indexed) - Phase 7E: Document scope tag
//   - document_total_tokens (integer) - Phase 7E: Total doc tokens
//   - is_microdoc (boolean, indexed) - Phase 7E: Microdoc flag
//   - source_path (string) - Phase 7E: Source file path
//   - tenant (string) - Phase 7E: Multi-tenancy
//
// ============================================================================
// VERIFICATION QUERIES (Commented - for manual testing)
// ============================================================================
// These queries can be uncommented and run separately to verify schema state.
// DO NOT uncomment for automated schema creation (they're for diagnostics).

// -- 1. Verify constraints exist (should return 16)
// SHOW CONSTRAINTS
// YIELD name, type, labelsOrTypes
// RETURN count(*) as constraint_count;

// -- 2. Verify property indexes exist (should return 41+)
// SHOW INDEXES
// YIELD name, type
// WHERE type IN ['RANGE', 'BTREE']
// RETURN count(*) as property_index_count;

// -- 3. Verify fulltext index exists (should return 1)
// SHOW INDEXES
// YIELD name, type
// WHERE type = 'FULLTEXT'
// RETURN name, 'BM25/keyword search' as purpose;

// -- 4. Verify vector indexes exist (should return 2)
// SHOW INDEXES
// YIELD name, type, labelsOrTypes
// WHERE type = 'VECTOR'
// RETURN name, labelsOrTypes, '1024-D cosine' as config;

// -- 5. Verify schema version
// MATCH (sv:SchemaVersion {id: 'singleton'})
// RETURN sv.version as version,
//        sv.vector_dimensions as dimensions,
//        sv.embedding_provider as provider,
//        sv.embedding_model as model,
//        sv.backup_source as backup_source,
//        sv.reform_note as reform_note;

// -- 6. Verify dual-labeling (after data ingestion)
// MATCH (s:Section)
// WITH count(s) as section_count
// MATCH (c:Chunk)
// RETURN section_count, count(c) as chunk_count,
//        CASE WHEN section_count = count(c) THEN 'PASS ✓' ELSE 'FAIL ✗' END as dual_label_test;

// ============================================================================
// END OF SCHEMA BACKUP v2.1 - CLEAN PRE-REFORM STATE
// ============================================================================
// Schema restoration complete!
//
// Next steps:
// 1. Verify Neo4j: SHOW CONSTRAINTS; SHOW INDEXES;
// 2. Verify SchemaVersion: MATCH (sv:SchemaVersion) RETURN sv;
// 3. Create Qdrant collection using Python script above
// 4. Verify Qdrant: curl http://localhost:6333/collections/chunks
// 5. Update chunking configuration to RAG best practices:
//    - combine_min_tokens: 350
//    - combine_target_tokens: 500
//    - combine_max_tokens: 750
// 6. Begin data ingestion with improved chunk sizes
//
// For troubleshooting:
// - Neo4j logs: docker logs weka-neo4j
// - Qdrant logs: docker logs weka-qdrant
// - Schema validation: scripts/verify_embedding_fields.py
//
// REFORM NOTE:
// This backup captures the schema in a clean state before implementing
// the chunking reform recommendations. After restoration, update the
// configuration in config/development.yaml to use smaller chunks
// (250-400 tokens) for better RAG retrieval performance.
//
// ============================================================================
