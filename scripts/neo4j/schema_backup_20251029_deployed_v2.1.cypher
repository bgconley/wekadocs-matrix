// ============================================================================
// WekaDocs GraphRAG Schema v2.1 - DEPLOYED SNAPSHOT BACKUP
// ============================================================================
// BACKUP METADATA:
//   Created:     2025-10-29
//   Source:      Production deployment (localhost:7687)
//   Schema Ver:  v2.1
//   Edition:     Neo4j Community Edition
//   Purpose:     Snapshot backup of deployed schema for disaster recovery
//
// BACKUP CAPTURE METHOD:
//   This file was generated by introspecting the running Neo4j database using:
//   - SHOW CONSTRAINTS (15 unique constraints captured)
//   - SHOW INDEXES (45 property + 2 vector indexes captured)
//   - Schema metadata from SchemaVersion node
//
// RESTORATION INSTRUCTIONS:
//   1. Neo4j: cat schema_backup_20251029_deployed_v2.1.cypher | cypher-shell -u neo4j -p <password>
//   2. Qdrant: See QDRANT_CONFIGURATION section below for Python restoration script
//   3. Verify: SHOW CONSTRAINTS; SHOW INDEXES; MATCH (sv:SchemaVersion) RETURN sv;
//
// IDEMPOTENCY:
//   This script is idempotent (IF NOT EXISTS on all CREATE statements).
//   Safe to re-run multiple times without errors or duplicates.
//
// COMPANION STORES:
//   Neo4j: This file (graph structure + constraints + indexes)
//   Qdrant: See QDRANT_CONFIGURATION section below for vector store setup
//
// DATA STATE AT BACKUP:
//   Neo4j:  0 nodes (schema-only backup after wipe)
//   Qdrant: 0 points (schema-only backup after wipe)
//
// CRITICAL SPECIFICATIONS:
//   Vector dimensions: 1024-D (Jina v3, not 384-D or 768-D)
//   Embedding provider: jina-ai
//   Model: jina-embeddings-v3
//   Similarity: cosine
//   Community Edition: No property existence constraints (enforced in app layer)
//
// ============================================================================

// ============================================================================
// PART 1: CORE NODE CONSTRAINTS (Document + Section + Entities)
// ============================================================================
// Purpose: Unique identifiers for all node types
// Impact: Prevents duplicate nodes, enables fast lookups
// Captured: 15 unique constraints from deployed schema

// Document constraints (2)
CREATE CONSTRAINT document_id_unique IF NOT EXISTS
FOR (d:Document) REQUIRE d.id IS UNIQUE;

CREATE CONSTRAINT document_source_uri_unique IF NOT EXISTS
FOR (d:Document) REQUIRE d.source_uri IS UNIQUE;

// Section constraint (1)
// NOTE: Sections are dual-labeled as :Chunk for v3 compatibility
CREATE CONSTRAINT section_id_unique IF NOT EXISTS
FOR (s:Section) REQUIRE s.id IS UNIQUE;

// Domain entity constraints (9)
CREATE CONSTRAINT command_id_unique IF NOT EXISTS
FOR (c:Command) REQUIRE c.id IS UNIQUE;

CREATE CONSTRAINT configuration_id_unique IF NOT EXISTS
FOR (c:Configuration) REQUIRE c.id IS UNIQUE;

CREATE CONSTRAINT procedure_id_unique IF NOT EXISTS
FOR (p:Procedure) REQUIRE p.id IS UNIQUE;

CREATE CONSTRAINT error_id_unique IF NOT EXISTS
FOR (e:Error) REQUIRE e.id IS UNIQUE;

CREATE CONSTRAINT concept_id_unique IF NOT EXISTS
FOR (c:Concept) REQUIRE c.id IS UNIQUE;

CREATE CONSTRAINT example_id_unique IF NOT EXISTS
FOR (e:Example) REQUIRE e.id IS UNIQUE;

CREATE CONSTRAINT step_id_unique IF NOT EXISTS
FOR (s:Step) REQUIRE s.id IS UNIQUE;

CREATE CONSTRAINT parameter_id_unique IF NOT EXISTS
FOR (p:Parameter) REQUIRE p.id IS UNIQUE;

CREATE CONSTRAINT component_id_unique IF NOT EXISTS
FOR (c:Component) REQUIRE c.id IS UNIQUE;

// Session/Query/Answer constraints (3)
CREATE CONSTRAINT session_id_unique IF NOT EXISTS
FOR (s:Session) REQUIRE s.session_id IS UNIQUE;

CREATE CONSTRAINT query_id_unique IF NOT EXISTS
FOR (q:Query) REQUIRE q.query_id IS UNIQUE;

CREATE CONSTRAINT answer_id_unique IF NOT EXISTS
FOR (a:Answer) REQUIRE a.answer_id IS UNIQUE;

// ============================================================================
// PART 2: PROPERTY INDEXES (Document, Section, Entities)
// ============================================================================
// Purpose: Fast filtering and sorting in queries
// Impact: Query performance optimization
// Captured: 43 property indexes from deployed schema

// Document indexes (3)
CREATE INDEX document_source_type IF NOT EXISTS
FOR (d:Document) ON (d.source_type);

CREATE INDEX document_version IF NOT EXISTS
FOR (d:Document) ON (d.version);

CREATE INDEX document_last_edited IF NOT EXISTS
FOR (d:Document) ON (d.last_edited);

// Section indexes (4)
CREATE INDEX section_document_id IF NOT EXISTS
FOR (s:Section) ON (s.document_id);

CREATE INDEX section_level IF NOT EXISTS
FOR (s:Section) ON (s.level);

CREATE INDEX section_order IF NOT EXISTS
FOR (s:Section) ON (s.order);

// Chunk indexes (3) - for dual-labeled nodes
CREATE INDEX chunk_document_id IF NOT EXISTS
FOR (c:Chunk) ON (c.document_id);

CREATE INDEX chunk_level IF NOT EXISTS
FOR (c:Chunk) ON (c.level);

CREATE INDEX chunk_embedding_version IF NOT EXISTS
FOR (c:Chunk) ON (c.embedding_version);

// Domain entity indexes (6)
CREATE INDEX command_name IF NOT EXISTS
FOR (c:Command) ON (c.name);

CREATE INDEX configuration_name IF NOT EXISTS
FOR (c:Configuration) ON (c.name);

CREATE INDEX procedure_title IF NOT EXISTS
FOR (p:Procedure) ON (p.title);

CREATE INDEX error_code IF NOT EXISTS
FOR (e:Error) ON (e.code);

CREATE INDEX concept_term IF NOT EXISTS
FOR (c:Concept) ON (c.term);

CREATE INDEX component_name IF NOT EXISTS
FOR (c:Component) ON (c.name);

// Session indexes (4)
CREATE INDEX session_started_at IF NOT EXISTS
FOR (s:Session) ON (s.started_at);

CREATE INDEX session_expires_at IF NOT EXISTS
FOR (s:Session) ON (s.expires_at);

CREATE INDEX session_active IF NOT EXISTS
FOR (s:Session) ON (s.active);

CREATE INDEX session_user_id IF NOT EXISTS
FOR (s:Session) ON (s.user_id);

// Query indexes (2)
CREATE INDEX query_turn IF NOT EXISTS
FOR (q:Query) ON (q.turn);

CREATE INDEX query_asked_at IF NOT EXISTS
FOR (q:Query) ON (q.asked_at);

// Answer indexes (2)
CREATE INDEX answer_created_at IF NOT EXISTS
FOR (a:Answer) ON (a.created_at);

CREATE INDEX answer_user_feedback IF NOT EXISTS
FOR (a:Answer) ON (a.user_feedback);

// ============================================================================
// PART 3: VECTOR INDEXES - 1024-D (CRITICAL for Phase 7E)
// ============================================================================
// Purpose: Semantic search via vector similarity
// CRITICAL SPECIFICATION: 1024 dimensions (Jina v3)
// Provider: jina-ai
// Model: jina-embeddings-v3
// Similarity: cosine
//
// DUAL INDEXES:
// We create two vector indexes on the same data (dual-labeled nodes):
// 1. section_embeddings_v2 - Primary retrieval path (Section label)
// 2. chunk_embeddings_v2 - v3 compatibility path (Chunk label)
//
// Both indexes point to the same vector_embedding property on the same nodes.
// Captured: 2 vector indexes from deployed schema

// Section vector index (primary retrieval path)
CREATE VECTOR INDEX section_embeddings_v2 IF NOT EXISTS
FOR (s:Section)
ON s.vector_embedding
OPTIONS {
  indexConfig: {
    `vector.dimensions`: 1024,
    `vector.similarity_function`: 'cosine'
  }
};

// Chunk vector index (v3 compatibility - same data, dual-labeled)
CREATE VECTOR INDEX chunk_embeddings_v2 IF NOT EXISTS
FOR (c:Chunk)
ON c.vector_embedding
OPTIONS {
  indexConfig: {
    `vector.dimensions`: 1024,
    `vector.similarity_function`: 'cosine'
  }
};

// ============================================================================
// PART 4: DUAL-LABELING FOR EXISTING SECTIONS (Migration-safe)
// ============================================================================
// Purpose: Add :Chunk label to existing :Section nodes for v3 compatibility
// Impact: Enables v3 tools to access sections via :Chunk label
// Pattern: Dual-labeling (not renaming) - both labels coexist
// Idempotent: WHERE NOT s:Chunk prevents redundant labeling
//
// For FRESH INSTALLATIONS, this is a no-op (no Sections exist yet).
// For MIGRATIONS, this adds :Chunk label to existing :Section nodes.

MATCH (s:Section)
WHERE NOT s:Chunk
SET s:Chunk;

// ============================================================================
// PART 5: SCHEMA VERSION MARKER (v2.1)
// ============================================================================
// Purpose: Track schema version for migrations and validation
// Pattern: Singleton node with version metadata
// Idempotent: MERGE ensures only one version node exists

MERGE (sv:SchemaVersion {id: 'singleton'})
SET sv.version = 'v2.1',
    sv.edition = 'community',
    sv.vector_dimensions = 1024,
    sv.embedding_provider = 'jina-ai',
    sv.embedding_model = 'jina-embeddings-v3',
    sv.updated_at = datetime(),
    sv.description = 'Phase 7C: Complete v2.1 schema with 1024-D vectors, dual-labeling, session tracking',
    sv.validation_note = 'Property existence constraints enforced in application layer (Community Edition)',
    sv.backup_source = 'Production deployment snapshot 2025-10-29',
    sv.backup_method = 'Introspected via SHOW CONSTRAINTS and SHOW INDEXES';

// ============================================================================
// PART 6: CANONICAL PROPERTY NAMES (Documentation)
// ============================================================================
// COMMUNITY EDITION NOTE:
// Property existence constraints (REQUIRE property IS NOT NULL) are not
// supported in Neo4j Community Edition. They require Enterprise Edition.
//
// VALIDATION STRATEGY:
// All required field validation is enforced in the application layer.
// See: src/shared/embedding_fields.py for validation logic.
//
// --------------------------------------------------------------------------
// CANONICAL PROPERTIES (Authoritative - used across Neo4j and Qdrant)
// --------------------------------------------------------------------------
// Section/Chunk nodes (dual-labeled :Section :Chunk):
//   - id                   (String, UNIQUE key)
//   - document_id          (String, FK to :Document.id)
//   - level                (Integer, heading depth)
//   - order                (Integer, position within parent)
//   - parent_section_id    (String, optional, logical parent anchor)
//   - heading              (String, optional)
//   - text                 (String, chunk text)
//   - is_combined          (Boolean)
//   - is_split             (Boolean)
//   - original_section_ids (List<String>)
//   - boundaries_json      (String, JSON-serialized bounds)
//   - token_count          (Integer)
//   - updated_at           (DateTime)
//   - vector_embedding     (List<Float>)  // 1024-D for jina-embeddings-v3
//   - embedding_version    (String)       // e.g., 'jina-embeddings-v3'
//   - embedding_provider   (String)       // e.g., 'jina-ai'
//   - embedding_dimensions (Integer)      // e.g., 1024
//   - embedding_timestamp  (DateTime)
//
// Document nodes:
//   - id                   (String, UNIQUE key)
//   - source_type          (String)
//   - source_uri           (String, UNIQUE)
//   - version              (String)
//   - last_edited          (DateTime)
//   - title                (String, optional)
//   - source_url           (String, optional)
//   - path                 (String, optional)
//   - token_count          (Integer, optional)
//
// Query nodes:
//   - query_id             (String, UNIQUE key)
//   - text                 (String)
//   - turn                 (Integer)
//   - asked_at             (DateTime)
//
// Answer nodes:
//   - answer_id            (String, UNIQUE key)
//   - text                 (String)
//   - created_at           (DateTime)
//   - user_feedback        (String, optional)
//
// Session nodes:
//   - session_id           (String, UNIQUE key)
//   - started_at           (DateTime)
//   - expires_at           (DateTime)
//   - active               (Boolean)
//   - user_id              (String, optional)
//
// ============================================================================
// PART 7: QDRANT CONFIGURATION (Companion Vector Store)
// ============================================================================
// The Qdrant collection must be created separately using the Python client.
// This section documents the exact configuration captured from deployment.
//
// COLLECTION NAME: weka_sections_v2
//
// RESTORATION SCRIPT (Python):
// --------------------------------------------------------------------------
// from qdrant_client import QdrantClient
// from qdrant_client.models import Distance, VectorParams
//
// client = QdrantClient(host="localhost", port=6333)
//
// # Create collection with exact deployed configuration
// client.create_collection(
//     collection_name="weka_sections_v2",
//     vectors_config=VectorParams(
//         size=1024,
//         distance=Distance.COSINE
//     ),
//     hnsw_config={
//         "m": 16,
//         "ef_construct": 100,
//         "full_scan_threshold": 10000,
//         "max_indexing_threads": 0,
//         "on_disk": False
//     },
//     optimizer_config={
//         "deleted_threshold": 0.2,
//         "vacuum_min_vector_number": 1000,
//         "default_segment_number": 0,
//         "indexing_threshold": 20000,
//         "flush_interval_sec": 5,
//         "max_optimization_threads": 1
//     },
//     wal_config={
//         "wal_capacity_mb": 32,
//         "wal_segments_ahead": 0
//     },
//     shard_number=1,
//     replication_factor=1,
//     write_consistency_factor=1,
//     on_disk_payload=True
// )
//
// # Create payload indexes for fast filtering
// client.create_payload_index(
//     collection_name="weka_sections_v2",
//     field_name="document_id",
//     field_schema="keyword"
// )
//
// client.create_payload_index(
//     collection_name="weka_sections_v2",
//     field_name="parent_section_id",
//     field_schema="keyword"
// )
//
// client.create_payload_index(
//     collection_name="weka_sections_v2",
//     field_name="order",
//     field_schema="integer"
// )
//
// client.create_payload_index(
//     collection_name="weka_sections_v2",
//     field_name="updated_at",
//     field_schema="integer"
// )
//
// print("Qdrant collection 'weka_sections_v2' created successfully")
// --------------------------------------------------------------------------
//
// DEPLOYED CONFIGURATION SUMMARY:
//   Collection:       weka_sections_v2
//   Vector Size:      1024 dimensions
//   Distance Metric:  Cosine
//   HNSW m:           16
//   HNSW ef_construct: 100
//   Shards:           1
//   Replication:      1
//   On-disk payload:  true
//   Status:           green (healthy)
//
// PAYLOAD SCHEMA (Canonical fields stored in Qdrant):
//   - id (string) - Matches Neo4j Section.id
//   - document_id (string, indexed) - FK to Document
//   - parent_section_id (string, indexed) - Logical parent
//   - level (integer) - Heading depth
//   - order (integer, indexed) - Position within parent
//   - heading (string) - Section heading
//   - text (string) - Full chunk text
//   - token_count (integer) - Token count
//   - is_combined (boolean) - Chunk combination flag
//   - is_split (boolean) - Chunk split flag
//   - original_section_ids (list<string>) - Source sections
//   - boundaries_json (string) - JSON-serialized bounds
//   - updated_at (integer/string, indexed) - Timestamp
//   - embedding_version (string) - Model version
//   - embedding_provider (string) - Provider name
//   - embedding_dimensions (integer) - Dimension count
//   - embedding_timestamp (string) - Embedding creation time
//
// ============================================================================
// VERIFICATION QUERIES (Commented - for manual testing)
// ============================================================================
// These queries can be uncommented and run separately to verify schema state.
// DO NOT uncomment for automated schema creation (they're for diagnostics).

// -- 1. Verify constraints exist (should return 15)
// SHOW CONSTRAINTS
// YIELD name, type, labelsOrTypes
// RETURN count(*) as constraint_count;

// -- 2. Verify property indexes exist (should return 43+)
// SHOW INDEXES
// YIELD name, type
// WHERE type IN ['RANGE', 'BTREE']
// RETURN count(*) as property_index_count;

// -- 3. Verify vector indexes exist (should return 2)
// SHOW INDEXES
// YIELD name, type, labelsOrTypes
// WHERE type = 'VECTOR'
// RETURN name, labelsOrTypes, '1024-D cosine' as config;

// -- 4. Verify schema version
// MATCH (sv:SchemaVersion {id: 'singleton'})
// RETURN sv.version as version,
//        sv.vector_dimensions as dimensions,
//        sv.embedding_provider as provider,
//        sv.embedding_model as model,
//        sv.backup_source as backup_source;

// -- 5. Verify dual-labeling (after data ingestion)
// MATCH (s:Section)
// WITH count(s) as section_count
// MATCH (c:Chunk)
// RETURN section_count, count(c) as chunk_count,
//        CASE WHEN section_count = count(c) THEN 'PASS ✓' ELSE 'FAIL ✗' END as dual_label_test;

// ============================================================================
// END OF SCHEMA BACKUP v2.1
// ============================================================================
// Schema restoration complete!
//
// Next steps:
// 1. Verify Neo4j: SHOW CONSTRAINTS; SHOW INDEXES;
// 2. Verify SchemaVersion: MATCH (sv:SchemaVersion) RETURN sv;
// 3. Create Qdrant collection using Python script above
// 4. Verify Qdrant: curl http://localhost:6333/collections/weka_sections_v2
// 5. Begin data ingestion
//
// For troubleshooting:
// - Neo4j logs: docker logs weka-neo4j
// - Qdrant logs: docker logs weka-qdrant
// - Schema validation: scripts/verify_embedding_fields.py
//
// ============================================================================
